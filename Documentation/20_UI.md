# UI del proyecto Saclisam

## Visión general
La UI del proyecto se divide en dos bloques principales:

1. **UI Reactiva** (HUDs y paneles con bindings automáticos).
2. **UI de Combate** (menús y selección de acciones/objetivos durante turnos).

El objetivo es evitar el polling en `Update()` y centralizar la actualización visual mediante **observables**, eventos y un **controlador de UI** por sistema.

---

## Estructura de carpetas

```
Assets/Scripts/UI/
├── UIReactiva.cs
├── Core/
│   ├── Observable.cs
│   ├── IBindableUI.cs
│   └── EntidadUIModel.cs
├── Components/
│   ├── BarraReactiva.cs
│   ├── BotonHabilidad.cs
│   ├── PanelEntidad.cs
│   └── TextoReactivo.cs
└── Combat/
    ├── CombatUIController.cs
    ├── CombatActionMenu.cs
    ├── SkillSelectionPanel.cs
    ├── SkillButton.cs
    └── TargetSelector.cs
```

También se usan eventos de UI definidos en:

```
Assets/Scripts/Events/EventosUI.cs
```

---

## 1) UI Reactiva (Core)

### Observable<T>
**Archivo:** `Assets/Scripts/UI/Core/Observable.cs`

- Contenedor de valor con notificación de cambios.
- Cuando cambia `Valor`, dispara `OnCambiado`.
- Se usa para exponer stats y estados a la UI.

**Puntos clave:**
- Evita el polling.
- Permite enlazar múltiples elementos a un mismo dato.

### IBindableUI
**Archivo:** `Assets/Scripts/UI/Core/IBindableUI.cs`

- Interfaz mínima para elementos refrescables.
- Todos los componentes reactivos implementan `Refrescar()`.

### EntidadUIModel
**Archivo:** `Assets/Scripts/UI/Core/EntidadUIModel.cs`

- Modelo de datos observable para entidades.
- Propiedades principales: `Nombre`, `VidaActual`, `VidaMaxima`, `ManaActual`, `ManaMaximo`, `Nivel`, `XPProgreso`, `EstaVivo`, `EsSuTurno`.
- Propiedades derivadas: `PorcentajeVida`, `PorcentajeMana`.

Este modelo es el puente entre lógica de juego y UI.

### UIReactiva
**Archivo:** `Assets/Scripts/UI/UIReactiva.cs`

- Singleton simple de registro de elementos de UI (`Registrar`, `Desregistrar`).
- Permite refrescar un elemento puntual (`Actualizar`) o todos (`ActualizarTodo`).

Uso típico:
- Cada componente UI registra su `idRegistro` en `Start()`.
- Se desregistra en `OnDestroy()`.

---

## 2) UI Reactiva (Componentes)

### BarraReactiva
**Archivo:** `Assets/Scripts/UI/Components/BarraReactiva.cs`

**Función:**
- Barra de vida/mana animada.
- Se vincula con `Observable<int>` para valor actual y máximo.

**Flujo:**
1. `Vincular(actual, maximo)` suscribe cambios.
2. `Refrescar()` calcula `valorObjetivo`.
3. `Update()` hace `Lerp` del fill y aplica gradiente.

### PanelEntidad
**Archivo:** `Assets/Scripts/UI/Components/PanelEntidad.cs`

**Función:**
- Panel completo de entidad (nombre, nivel, barras, indicador de turno).

**Flujo:**
1. `Vincular(EntidadUIModel)`.
2. Vincula barras con `BarraReactiva`.
3. Suscribe `Nombre`, `Nivel`, `EsSuTurno`, `EstaVivo`.
4. `Refrescar()` pinta el estado inicial.

### TextoReactivo
**Archivo:** `Assets/Scripts/UI/Components/TextoReactivo.cs`

**Función:**
- Texto con binding automático.

**Formas de uso:**
- `Vincular(Func<string>)`.
- `Vincular<T>(Observable<T>)` (auto-refresco al cambiar).

### BotonHabilidad (UI Reactiva)
**Archivo:** `Assets/Scripts/UI/Components/BotonHabilidad.cs`

**Función:**
- Botón de habilidad con cooldown visual.
- Usa `GestorCooldowns` para activar/desactivar y mostrar overlay.

**Flujo:**
1. `Configurar(habilidad, cooldowns, onClick)`.
2. `Refrescar()` sincroniza interactable + cooldown.
3. `OnClick()` dispara callback si está disponible.

---

## 3) UI de Combate

### CombatUIController
**Archivo:** `Assets/Scripts/UI/Combat/CombatUIController.cs`

**Responsabilidad:**
- Controla el estado global de la UI en combate.
- Escucha eventos del `EventBus`.
- Coordina paneles (acciones, habilidades, selector de objetivos).
- Cambia el contexto de input (`GameInputManager`).

**Eventos escuchados:**
- `EventoCombateIniciado`
- `EventoCombateFinalizado`
- `EventoEsperandoAccionJugador`
- `EventoTurnoFinalizado`

**Estados principales (`CombatUIState`):**
- `Hidden`
- `WaitingForEntityClick`
- `ShowingActionMenu`
- `ShowingSkillPanel`
- `SelectingTarget`

**Flujo general:**
1. Al iniciar combate, activa `combatUIRoot` y cambia contexto a `Combat`.
2. Cuando es el turno de un personaje, muestra indicador y highlight.
3. Click sobre el personaje => abre `CombatActionMenu`.
4. Acción "Atacar" => abre `SkillSelectionPanel`.
5. Seleccionar habilidad => abre `TargetSelector`.
6. Cancelar (`Esc` o click derecho) vuelve al estado previo.

### CombatCharacterPanel (NUEVO)
**Archivo:** `Assets/Scripts/UI/Combat/CombatCharacterPanel.cs`

**Función:**
- Panel principal de personaje en combate.
- Muestra info del personaje seleccionado (aunque no sea su turno).
- Habilita/deshabilita acciones según si es el turno del personaje.

**Componentes visuales:**
- Imagen del personaje (`SpritePersonaje` de `ClaseData.iconoClase`)
- Nombre y nivel
- Barra de vida (animada)
- Barra de mana/recurso (placeholder, será dinámica)
- Botones de acción: Habilidades, Usar Item, Defender
- Panel dinámico de habilidades (se despliega al clickear "Habilidades")
- Contenedores de buffs/debuffs
- Botón de refuerzos (visible si hay personajes estacionados)

**Flujo:**
1. Click en personaje → `MostrarPersonaje(entity)`.
2. Si es su turno, botones de acción habilitados.
3. Click en "Habilidades" → oculta botones de acción, muestra panel de habilidades.
4. Click en habilidad → cierra panel, publica `EventoAccionSeleccionada`.
5. "Defender" → ejecuta directamente (sin selección de objetivo).

### AbilityButtonUI (NUEVO)
**Archivo:** `Assets/Scripts/UI/Combat/AbilityButtonUI.cs`

**Función:**
- Botón de habilidad para el panel dinámico.
- Muestra: nombre, icono, daño estimado, tipo objetivo, costo, efecto.

**Configuración:**
- `Configurar(habilidad, danoCalculado, disponible, onClick)`
- Calcula elemento del primer `DamageEffect`.
- Muestra estado visual según disponibilidad (cooldown, sin recursos).

### CombatActionMenu
**Archivo:** `Assets/Scripts/UI/Combat/CombatActionMenu.cs`

**Función:**
- Menú contextual de acciones (Atacar, Usar Item, Defender, Ceder Turno, Huir).
- Puede seguir al personaje en pantalla.
- Fade in/out con `CanvasGroup`.

**Detalles:**
- `UpdateButtonStates()` deshabilita acciones no implementadas.
- `SetButtonTexts(...)` permite cambiar textos.

### SkillSelectionPanel
**Archivo:** `Assets/Scripts/UI/Combat/SkillSelectionPanel.cs`

**Función:**
- Panel de selección de habilidades (versión anterior).
- Genera botones dinámicos y muestra info de la habilidad.

**Nota:** Este panel puede ser reemplazado por el sistema integrado en `CombatCharacterPanel`.

### SkillButton
**Archivo:** `Assets/Scripts/UI/Combat/SkillButton.cs`

**Función:**
- Botón individual con ícono, nombre y cooldown.

**Notas de uso:**
- `Initialize(...)` calcula disponibilidad y configura visual.
- `OnPointerEnter/Exit()` no usan interfaces de Unity por defecto: se recomienda
  configurar eventos en el `EventTrigger` del botón para invocar estos métodos.

### TargetSelector
**Archivo:** `Assets/Scripts/UI/Combat/TargetSelector.cs`

**Función:**
- Modo de selección de objetivos.
- Crea indicadores sobre aliados/enemigos.
- Resalta objetivos con hover.

**Detalles clave:**
- `Show(skill, allies, enemies)` calcula objetivos válidos según `TargetType`.
- Usa `IsometricCameraController` (o cámara principal) para raycast.
- Indicadores cambian color según aliado/enemigo y selección.

---

## 4) Input y UI

**Archivo:** `Assets/Scripts/Input/GameInputManager.cs`

- `CombatUIController` y `CombatCharacterPanel` se suscriben a:
  - `OnEntityClick`
  - `OnEnemyClick`
  - `OnCancelAction`
- Los clicks sobre UI se ignoran usando `EventSystem.IsPointerOverGameObject()`.
- El contexto de input se cambia con `SetContext()` cuando inicia/finaliza combate.

---

## 5) Eventos de UI

**Archivo:** `Assets/Scripts/Events/EventosUI.cs`

- `EventoMostrarMensaje`: muestra mensajes temporales.
- `EventoActualizarUI`: permite refrescar un panel específico por `PanelId`.

Este sistema puede integrarse con `UIReactiva.Instance.Actualizar(id)`.

---

## 6) Cómo extender la UI

### Nuevo componente reactivo
1. Implementar `IBindableUI`.
2. Exponer `idRegistro` para registro automático.
3. En `Start()` registrar en `UIReactiva.Instance`.
4. En `OnDestroy()` desregistrar.
5. Suscribirse a observables y llamar `Refrescar()`.

### Nuevo panel de combate
1. Crear el panel en Canvas y su script controlador.
2. Inyectarlo en `CombatUIController` por inspector.
3. Enlazar el panel en el flujo de estados.

---

## 7) Resumen de flujo (alto nivel)

```
Entidad (lógica)
   ↓
EntidadUIModel (Observable<T>)
   ↓
Componentes UI (BarraReactiva, PanelEntidad, TextoReactivo)
   ↓
UIReactiva (refrescos manuales/masivos)

Combate (NUEVO FLUJO)
   ↓
EventBus + GameInputManager
   ↓
CombatCharacterPanel (panel principal)
   ↓
Click en personaje → mostrar info
   ↓
Si es su turno: Botones de acción habilitados
   ↓
"Habilidades" → AbilityButtonUI (lista dinámica)
   ↓
Selección de habilidad → TargetSelector
```
